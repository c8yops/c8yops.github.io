[[{"l":"Welcome to c8yops guides"}],[{"l":"Git Cheat Sheet"},{"l":"01 Git installation","p":["Linux:","For GNU/Linux distributions, Git should be available in the standard system repository. For example, in Debian/Ubuntu please type in the terminal:","Windows:","https://windows.github.com","Mac:","https://mac.github.com","Git for All Platforms:","https://git-scm.com"]},{"l":"02 Git configuration","p":["Set the name that will be attached to your commits and tags.","Set the e-mail address that will be attached to your commits and tags.","Set automatic command line coloring for Git for easy reviewing."]},{"l":"03 Starting a Project","p":["Create a new local repository. If [project name] is provided, Git will create a new directory name [project name] and will initialize a repository inside it. If [project name] is not provided, then a new repository is initialized in the current directory.","Downloads a project with the entire history from the remote repository."]},{"l":"04 Day-To-Day Work","p":["Displays the status of your working directory. Options include new, staged, and modified files. It will retrieve branch name, current commit identifier, and changes pending commit.","Add a file to the staging area. Use in place of the full file path to add all changed files from the current directory down into the directory tree.","Show changes between working directory and staging area.","Shows any changes between the staging area and the repository.","Discard changes in working directory. This operation is unrecoverable.","Revert your repository to a previous known working state.","Create a new commit from changes added to the staging area. The commit must have a message!","Remove file from working directory and staging area.","Put current changes in your working directory into stash for later use.","Apply stored stash content into working directory, and clear stash.","Delete a specific stash from all your previous stashes."]},{"l":"05 Git branching model","p":["List all local branches in repository. With -a: show all branches (with remote).","Create new branch, referencing the current HEAD.","Switch working directory to the specified branch. With -b: Git will create the specified branch if it does not exist.","Join specified [from name] branch into your current branch (the one you are on currently).","Remove selected branch, if it is already merged into any other.-D instead of -d forces deletion."]},{"l":"06 Review your work","p":["List commit history of current branch. -n count limits list to last n commits.","An overview with reference labels and history graph. One commit per line.","List commits that are present on the current branch and not merged into ref. A ref can be a branch name or a tag name.","List commit that are present on ref and not merged into current branch.","List operations (e.g. checkouts or commits) made on local repository."]},{"l":"07 Tagging known commits","p":["List all tags.","Create a tag reference named name for current commit. Add commit sha to tag a specific commit instead of current one.","Create a tag object named name for current commit.","Remove a tag from local repository."]},{"l":"08 Reverting changes","p":["Switches the current branch to the target reference, leaving a difference as an uncommitted change. When --hard is used, all changes are discarded.","Create a new commit, reverting changes from the specified commit. It generates an inversion of changes."]},{"l":"09 Synchronizing repositories","p":["Fetch changes from the remote, but not update tracking branches.","Delete remote Refs that were removed from the remote repository.","Fetch changes from the remote and merge current branch with its upstream.","Push local changes to the remote. Use --tags to push tags.","Push local branch to remote repository. Set its copy as an upstream.","an object","a reference to a commit; can have a tracked upstream","a reference (standard) or an object (annotated)","a place where your working directory is now"]},{"l":"10 Ignoring Files","p":["Verify the .gitignore file exists in your project and ignore certain type of files, such as all files in logs directory (excluding the .gitkeep file), whole tmp directory and all files *.swp. File ignoring will work for the directory (and children directories) where .gitignore file is placed.","System wide ignore pattern for all local repositories."]}],[{"l":"Version Control"},{"l":"Best practices"},{"l":"Commit Related Changes","p":["A commit should be a wrapper for related changes. For example, fixing two different bugs should produce two separate commits. Small commits make it easier for other developers to understand the changes and roll them back if something went wrong. With tools like the staging area and the ability to stage only parts of a file, Git makes it easy to create very granular commits."]},{"l":"Commit Often","p":["Committing often keeps your commits small and, again, helps you commit only related changes. Moreover, it allows you to share your code more frequently with others. That way it’s easier for everyone to integrate changes regularly and avoid having merge conflicts. Having few large commits and sharing them rarely, in contrast, makes it hard to solve conflicts."]},{"l":"Do Not Commit Half-done Work","p":["You should only commit code when it’s completed. This doesn‘t mean you have to complete a whole, large feature before committing. Quite the contrary: split the feature’s implementation into logical chunks and remember to commit early and often. But don’t commit just to have something in the repository before leaving the office at the end of the day. If you’re tempted to commit just because you need a clean working copy (to check out a branch, pull in changes, etc.) consider using Git’s «Stash» feature instead."]},{"l":"Test Code Before You Commit","p":["Resist the temptation to commit something that you «think» is completed. Test it thoroughly to make sure it really is completed and has no side effects (as far as one can tell). While committing half-baked things in your local repository only requires you to forgive yourself, having your code tested is even more important when it comes to pushing/sharing your code with others."]},{"l":"Write Good Commit Messages","p":["Begin your message with a short summary of your changes (up to 50 characters as a guideline). Separate it from the following body by including a blank line. The body of your message should provide detailed answers to the following questions: › What was the motivation for the change? › How does it differ from the previous implementation? Use the imperative, present tense («change», not «changed» or «changes») to be consistent with generated messages from commands like git merge."]},{"l":"Version Control is Not a Backup System","p":["Having your files backed up on a remote server is a nice side effect of having a version control system. But you should not use your VCS like it was a backup system. When doing version control, you should pay attention to committing semantically (see «related changes ») - you shouldn‘t just cram in files."]},{"l":"Use Branches","p":["Branching is one of Git’s most powerful features - and this is not by accident: quick and easy branching was a central requirement from day one. Branches are the perfect tool to help you avoid mixing up different lines of development. You should use branches extensively in your development workflows: for new features, bug fixes, ideas…"]},{"l":"Agree on a Workflow","p":["Git lets you pick from a lot of different workflows: long-running branches, topic branches, merge or rebase, git-flow… Which one you choose depends on a couple of factors: your project, your overall development and deployment workflows and (maybe most importantly) on your and your teammates‘ personal preferences. However, you choose to work, just make sure to agree on a common workflow that everyone follows."]},{"i":"help--documentation","l":"Help & Documentation","p":["Get help on the command line"]},{"l":"Free Online Resources","p":["https://www.git-scm.org/","https://marklodato.github.io/visual-git-guide/index-en.html"]}],[{"l":"Working With Branches in Git"},{"l":"Creating a New Branch","p":["This is where the fun starts. Simply type this command to create a new branch, so that you can work on a feature or fix a bug in isolation:","Keep in mind that you can only create new branches in your local repository(you will see them remotely when published).","By default, the new branch will be based on your currently checked out revision. If you’d like to start at a specific revision, simply add that revision’s hash at the end of the command, like so:","Make sure you give meaningful names to your branches - something like “feature-being-worked-on” could be a good starting point."]},{"l":"Switching Branches","p":["To switch to a different branch and make it active ( setting it as the HEAD branch), you can rely on either “switch” or “checkout”. We like “switch”, as it is self-explanatory and “checkout” can be used for other tasks, but both are valid.","OR"]},{"l":"Renaming Branches","p":["This command assumes you’ve already checked out the branch you’d like to rename (your local HEAD branch):","If you’d like to rename a different branch, you should first insert the current name, like in this example:"]},{"l":"Publishing Branches","p":["While you can’t create new branches on remote repositories, you can most definitely publish an existing local branch by typing this command:","Since you’re not allowed to rename remote branches, you can delete the old one and then push a new one by typing these two commands:"]},{"l":"Tracking Branches","p":["This is an important command to create relationships between local and remote branches- since initially, they don’t have any!","The most common example is having a local branch track a remote one, so that you can simply type “git push” or “git pull” without additional parameters to keep everything in sync. This can be quickly achieved by typing the command below:","You can also use the “git checkout” command to achieve this. If you want to name the local branch after the remote one, you only have to specify the remote branch’s name:"]},{"l":"Comparing Branches","p":["This is a very useful command when you need to decide if you should integrate or delete a branch, as it presents you the commits that were created exclusively in there.","You can also use this command to compare local and remote states, like in the example below:"]},{"l":"Merging Branches","p":["When it is time to integrate the new changes into your current HEAD branch, it is time to merge!","Merging consists of two steps: you will need to switch to the branch that will receive the new changes first, and then type the “git merge” command:"]},{"l":"Rebasing Branches","p":["Rebasing is an alternative to merging - both achieve the same goal, but the Rebase option re-writes the project history, creating a straight line. As a result, you get a linear history, which may be preferred by some teams.","Rebasing consists of two steps: you will need to switch to the feature branch first, and then type the “git rebase” command:"]},{"l":"Deleting Branches","p":["When a local branch is no longer needed, you can delete it by typing the command below:","If that branch contains unmerged changes, you might also need the “-f” option to force the deletion - if so, proceed with caution!","To delete a remote branch, keep in mind that the command is totally different:","To avoid a messy repository, make sure you periodically look for obsolete branches and delete them."]}]]